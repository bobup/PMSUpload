<?php

// UploadSupport.php

// Copyright (c) 2019 Bob Upshaw.  This software is covered under the Open Source MIT License


define( "DATE_TIME_FORMAT", "Y-m-d H:i:s" );		// e.g. "2019-01-03 18:06:09"
define( "ENCRYPT_METHOD", "aes-128-ctr");
define( "ENCRYPT_KEY", "%C*F)J@NcRfUjXn2" );		// NOTE:
	// The above key should change often to prevent key breaking by gathering lots of encrypted data.
	// For now it's "constant" but we can add greater security if necessary by changing the key daily or
	// more often.

/*
 * US_GenerateValidKey -  Generate a key that a Drupal side request will include when invoking
 * 		a file upload utility.
 *
 * PASSED:
 * 	n/a
 *
 * RETURNED:
 * 	$key - the (unencripted) key to be used.  It has a short lifetime so the caller of this routine must use it
 * 		soon!
 *
 */
function US_GenerateValidKey() {
	$now = new DateTime( "now", new DateTimeZone( "America/Los_Angeles" ) );
	$key = $now->format( DATE_TIME_FORMAT );
	return $key;
} // end of US_GenerateValidKey()


/*
 * US_ExtractKeyFromValue - Extract the (unencripted) key from the passed value.
 *
 * PASSED:
 * 	$value - a string which contains the key.
 *
 * RETURNED:
 * 	$key - the extracted key, or an empty string if no key is found.
 *
 * NOTES:
 * 	$value is assumed to be of the form:
 * 		xxx...xxxKKKKKzzz...zzz
 * 	where
 * 		xxx...xxx is a string of exactly 12 unencripted characters, beginning with "U", and
 * 		zzz...zzz is a string of exactly 8 unencripted characters.
 * 	If $value does NOT begin with a "U" it must begin with a "E", in which case the remaining
 * 	part of $value is assumed to be an encrypted string, which will be decripted and must then
 * 	match the description above.  Any failure will result in an empty string being returned.
 * 	
 */
function US_ExtractKeyFromValue( $value ) {
	$key = "";
	$clear = "";
	// is $value encrypted?
	$firstChar = substr( $value, 0, 1 );
	if( !$firstChar ) {
		// no first char!
		$key = "";
	} else if( $firstChar == "E" ) {
		// encrypted string - decrypt it
		$realValue = substr( $value, 1 );
		$clear = openssl_decrypt( $realValue, ENCRYPT_METHOD, ENCRYPT_KEY );
	} else if( $firstChar == "U" ) {
		// $value is in the clear
		$clear = $value;
	} else {
		// invalid first char
		$key = "";
	}
	if( $clear != "" ) {
		// at this point $clear contains our cleartext key surrounded by junk
		$clear = substr( $clear, 12 );
		if( $clear ) {
			$clear = substr( $clear, 0, -8 );
		}
		if( $clear ) {
			$key = $clear;
		} else {
			$key = "";
		}
	}
	return $key;
} // end of US_ExtractKeyFromValue()


/*
 * US_GenerateBuriedKey - Generate a (possibly encrypted) string containing the passed key.
 *
 * PASSED:
 * 	$key - the key to be buried into the returned string
 * 	$encrypt - true if the returned string is encrypted, false if the returned string is kept
 * 		in the clear.
 *
 * RETURNED:
 * 	$buriedKey - the returned string containing the passed key.
 *
 * NOTES:
 * 	See the Notes for US_ExtractKeyFromValue() for a description of the $buriedKey.
 *
 */
function US_GenerateBuriedKey( $key, $encrypt ) {
	// generate the left-hand random part of our buried key:
	$str = rand();
	$head = sha1( $str );
	$head = substr( $head, 0, 11 );
	$head = "U" . $head;

	// generate the right-hand random part of our buried key:
	$str = rand();
	$tail = sha1( $str );
	$tail = substr( $tail, 0, 8 );
	
	// generate our cleartext result:
	$buriedKey = $head . $key . $tail;
	
	// encrypt it if required:
	if( $encrypt ) {
		$encryptedBuriedKey = openssl_encrypt( $buriedKey, ENCRYPT_METHOD, ENCRYPT_KEY );
		$buriedKey = "E" . $encryptedBuriedKey;
	}
	return $buriedKey;
} // end of US_GenerateBuriedKey()


// 	if( US_KeysMatch( $passedKey, $expectedKey ) )
/*
 * US_KeysMatch - compare the two passed keys and return the result
 *
 * PASSED:
 * 	$passedKey - key to match (in the form generated by US_GenerateValidKey)
 * 	$expectedKey - other key to match (in the form generated by US_GenerateValidKey)
 *
 * RETURNED:
 * 	$result - true if the keys "match", false otherwise.
 *
 * NOTES:
 * 	The notion of "match" may allow the keys to be "close".  For example, this implementation
 * 	will use date/time as the key, and in that the case the keys will "match" if they are
 * 	fairly close to each other in time.
 *
 */
function US_KeysMatch( $passedKey, $expectedKey ) {
	$result = false;
	$passedDateTime = DateTime::createFromFormat( DATE_TIME_FORMAT, $passedKey );
	$expectedDateTime = DateTime::createFromFormat( DATE_TIME_FORMAT, $expectedKey );

	if( !$passedDateTime || !$expectedDateTime ) {
		// one/both passed "times" are not date/times!
		$result = false;
	} else {
		// how close are these two times?
		$interval = $passedDateTime->diff( $expectedDateTime, true );
		if( ($interval->y > 0) ||
			($interval->m > 0) ||
			($interval->d > 0) ||
			($interval->h > 0) ||
			($interval->i > 0) ||
			($interval->s > 55) ) {
			// not close enough!
			$result = false;
		} else {
			$result = true;
		}
	}
	return $result;	
} // end of US_KeysMatch()


// 		list( $isValidRequest, $expectedUserName ) = US_ValidateUserName( $UserName );
/*
 * US_ValidateUserName - see if the passed "user name" is good enough to let this user
 *	upload a file.
 *
 * PASSED:
 *	$userName - a string of the form "xxxxZZ", where 'xxxx' is a name we recognized, and
 *		'ZZ' is the day of the month (01 - 31)
 *
 * RETURNED:
 *	$isValidRequest - true if the passed userName is "valid", false otherwise
 *	$fullName - the full name of the user that ATTEMPTED TO log in if we can figure it out.
 *		Otherwise it's an empty string.
 *	$userName - the user name passed to this routine, obfuscated.
 *
 * NOTES:
 *	This is a simple hack used to give us a little protection from someone trying to upload 
 *	bogus files. No longer depends on Drupal. Bummer.
 *
 */
 function US_ValidateUserName ( $userName ) {
 	$result = false;
 	$returnedFullName = "";
	$now = new DateTime( "now", new DateTimeZone( "America/Los_Angeles" ) );
	$day = $now->format( 'd' );		// 01 -> 31
	
	$validNames = array (
		"Chris Ottati" => "ChriS",
		"Bob Upshaw" => "BobUp"
	);
	
	preg_match( '/(^.*)(..$)/', $userName, $matches );
	// At this point $matches[1] is the user's supplied login name, and $matches[2] is
	// the 2 digits representing the day of the month supplied by the user.
	if( !is_numeric( $matches[2] ) ) {
		// this is wrong already, but look for a common mistake and see if we can guess
		// the name of the user trying to authenticate:
		$matches[1] = $userName;
	}
	
	//error_log( "userName='$userName', day='$day', $matches[1], $matches[2]");
	$validUserName = "";
	$validFullName = "";
	
	// see if we have a valid user name
	foreach( $validNames as $arrayFullName => $arrayUserName ) {
		if( $matches[1] == $arrayUserName ) {
			$validUserName = $arrayUserName;
			$validFullName = $arrayFullName;
			break;
		}
	}

	if( $validUserName != "" ) {
		$returnedFullName = $validFullName;
		if( $day == $matches[2] ) {
			// we have a valid login
			$result = true;
		}
	}
	
	$obUserName = US_Obfuscate( $userName );
	return array( $result, $returnedFullName, $obUserName );
 } // end of US_ValidateUserName()


function US_Obfuscate( $str ) {
	$lastIndex = strlen($str) - 1;
	
	for( $i = 0; $i <= $lastIndex; $i++ ) {
		$ordOfChar = ord( $str[$i] );
		if( $i % 2 ) {
			$ordOfChar++;
		} else {
			$ordOfChar--;
		}
		$str[$i] = chr( $ordOfChar );
	}
	return $str;

} // end of US_Obfuscate()




?>