<?php

// UploadSupport.php
/***** NOTE: the user of this file (the code that does a "require" of this file) must define '$localProps'
 ***** See LocalProps.php and LocalProps.txt.
 *****/

// Copyright (c) 2019-2022 Bob Upshaw.  This software is covered under the Open Source MIT License

define( "DEBUG", "0" );		// 0=no debugging, >0 turn on debugging
define( "DEBUG_RSIND", "0" );	// used only to enable/disable emails and distribution of the RSIND
//define( "DEBUG_RSIND", "1" );	// used only to enable/disable emails and distribution of the RSIND
								// file to the various destinations. 
								// 0 = enable emails to 
								// 	rsind_uploads@pacificmasters.org and distribute the RSIND file.
								// 1 = email to single person (see RSIND_EMAIL_RECIPIENTS) and 
								// 	DON'T distribute the RSIND file.
								//	Also, allow duplicate RSIND file uploads.
define( "DEBUG_OW", "0" );		// used only to enable/disable emails. 0 = enable emails 
								// to ow_uploads@pacificmasters.org
								// 1 = email to single person (see OW_EMAIL_RECIPIENTS)
define( "MAX_AGE_KEY", "50" );	// The max age of a user's session, in minutes.
//define( "MAX_AGE_KEY", "0" );	// The max age of a user's session, in minutes.

if( DEBUG > 10 ) {
	error_log( "Entered UploadSupport.php\n" );
}

define( "DATE_TIME_FORMAT", "Y-m-d H:i:s" );		// e.g. "2019-01-03 18:06:09"
define( "ENCRYPT_METHOD", "aes-128-ctr");
define( "ENCRYPT_KEY", "%C*F)J@NcRfUjXn2" );		// NOTE:
	// The above key should change often to prevent key breaking by gathering lots of encrypted data.
	// For now it's "constant" but we can add greater security if necessary by changing the key daily or
	// more often.

// here is our "secret" property file containing valid login names:
$secretProps = $localProps[2];

// here is where we store valid "login" names:
$validNames = array();

if( DEBUG_RSIND ) {
	define( "RSIND_EMAIL_RECIPIENTS", "bobup@acm.org" );
	define( "NO_COPY_RSIND", "nocopy" );	// NO_COPY_RSIND is set to non-empty if we don't 
	// really want to copy RSIND files to the appropriate
	// destination locations. This is useful during debugging. During normal operations we want
	// to set NO_COPY_RSIND to an empty string.
} else {
	// RSIND_EMAIL_RECIPIENTS is the recipient of all emails related to RSIND uploads:
	define( "RSIND_EMAIL_RECIPIENTS", "rsind_uploads@pacificmasters.org" );
	define( "NO_COPY_RSIND", "" );	// see above
}
if( DEBUG_OW ) {
	define( "OW_EMAIL_RECIPIENTS", "bobup@acm.org" );
} else {
	// OW_EMAIL_RECIPIENTS is the recipient of all emails related to OW result uploads:
	define( "OW_EMAIL_RECIPIENTS", "ow_uploads@pacificmasters.org" );
}


// initialization...
$thisYear = date("Y");		// the year in which we are running
$previousYear = $thisYear-1;	// the year prior to this year

$uploadType = $_SESSION['uploadType'];
$UserName = $_SESSION['UserName'];
$encrypted = $_SESSION['encrypted'];
$UsersFullName = $_SESSION['UsersFullName'];
$yearBeingProcessed = $_SESSION['year'];
// remove surrounding parens...
$yearBeingProcessed = str_replace( "(", "", $yearBeingProcessed );
$yearBeingProcessed = str_replace( ")", "", $yearBeingProcessed );

// We will put ALL uploaded files into this directory:
$destinationDirRoot = "../UploadedFiles/OW/";		// relative to the location of this script in the webserver tree.
$destinationDirRootFull = realpath( $destinationDirRoot ) . "/";
// Note:  the above directory is relative to the location of this script in the webserver tree.
$destinationDirTmp = $destinationDirRootFull . "tmp/";
$destinationDirArchive = $destinationDirRootFull . "Archive/$yearBeingProcessed/";
if( DEBUG > 99 ) {
	error_log( "Upload destination (tmp) directory is '$destinationDirTmp', Archive = '$destinationDirArchive'\n" );
}

/*
** How login and encryption work:  When a valid user first invokes the Upload facility they will
** request Upload.html. Upon submitting their User Name it will be passed to PostAnUpload.php which
** will validate the User Name using:
**		US_ValidateUserName( userName ) below. 
** If valid, US_ValidateUserName() will return $obUserName, which is an "obfuscated" version of 
** the user name. It gets this by invoking:
**		US_Obfuscate( userName )
** Once the userName is validated a special "valid key" is generated by invoking
**		US_GenerateValidKey(). 
** This "valid key" is a simple timestamp. Once we have a "valid key" we generate a random
** string into which we imbed the valid key, and then encrypt the whole thing and call this
** the user's "encrypted key". The generation of this "encrypted key" is done by invoking
**		US_GenerateBuriedKey( k, true ),
** where k is the "valid key". This encrypted key is then kept in the user's session and
** is checked for every request to the Upload facility. This checking is performed by invoking
**		US_ExtractKeyFromValue( encrypted key )
** and then comparing the extracted "valid key" with the current time.
** Note that the "valid key" will age, eventually causing that key to become invalid. Therefore, 
** to decide whether or not the extracted key is truely valid or not we use
**		US_TestValidKey( encrypted key )
**
*/



// 		list( $isValidRequest, $expectedUserName ) = US_ValidateUserName( $UserName, $uploadType );
/*
 * US_ValidateUserName - see if the passed "user name" is good enough to let this user
 *	upload a file.
 *
 * PASSED:
 *	$userName - a string of the form "xxxxZZ", where 'xxxx' is a name we recognized, and
 *		'ZZ' is the day of the month (01 - 31)
 #	$uploadType - the type of uploaded, one of "RSIND", or "OW".
 *
 * RETURNED:
 *	$isValidRequest - true if the passed userName is "valid" for the passed uploadType, false otherwise
 *	$fullName - the full name of the user that ATTEMPTED TO log in if we can figure it out.
 *		Otherwise it's an empty string.
 *	$obUserName - the user name passed to this routine, obfuscated.
 *
 * NOTES:
 *	This is a simple hack used to give us a little protection from someone trying to upload 
 *	bogus files. No longer depends on Drupal. Bummer.
 *
 */
 function US_ValidateUserName ( $userName, $uploadType ) {
 	$result = false;
 	$returnedFullName = "";
	if( DEBUG ) {
		//error_log( "US_ValidateUserName() entered.");
	}
	$now = new DateTime( "now", new DateTimeZone( "America/Los_Angeles" ) );
	$day = $now->format( 'd' );		// 01 -> 31
	
	if( empty( $validNames ) ) {
		US_GetValidNames( $validNames, $uploadType );
	}
	
	preg_match( '/(^.*)(..$)/', $userName, $matches );
	// At this point $matches[1] is the user's supplied login name, and $matches[2] is
	// the 2 digits representing the day of the month supplied by the user.
	if( DEBUG ) {
		//error_log( "US_ValidateUserName: supplied name: $matches[1], day: $matches[2]");
	}
	
	
	//error_log( "userName='$userName', day='$day', $matches[1], $matches[2]");
	$validUserName = "";
	$validFullName = "";
	
	// see if we have a valid user name
	foreach( $validNames as $arrayFullName => $arrayUserName ) {
		if( $matches[1] == $arrayUserName ) {
			$validUserName = $arrayUserName;
			$validFullName = $arrayFullName;
			break;
		}
	}

	if( $validUserName == "" ) {
		// nope - not valid. But check for common error so we can report their name
		$matches[1] = $userName;
		// see if we have a valid user name without the trailing digits
		foreach( $validNames as $arrayFullName => $arrayUserName ) {
			if( $matches[1] == $arrayUserName ) {
				$validUserName = $arrayUserName;
				$validFullName = $arrayFullName;
				break;
			}
		}
	}
	
	if( $validUserName != "" ) {
		$returnedFullName = $validFullName;
		if( $day == $matches[2] ) {
			// we have a valid login
			$result = true;
		}
	}
	
	$obUserName = US_Obfuscate( $userName );
	return array( $result, $returnedFullName, $obUserName );
 } // end of US_ValidateUserName()



function US_Obfuscate( $str ) {
	$lastIndex = strlen($str) - 1;
	
	for( $i = 0; $i <= $lastIndex; $i++ ) {
		$ordOfChar = ord( $str[$i] );
		if( $i % 2 ) {
			$ordOfChar++;
		} else {
			$ordOfChar--;
		}
		$str[$i] = chr( $ordOfChar );
	}
	return $str;

} // end of US_Obfuscate()



/*
 * US_GenerateValidKey -  Generate a key that a HTML side request will include when invoking
 * 		a file upload utility.
 *
 * PASSED:
 * 	n/a
 *
 * RETURNED:
 * 	$key - the (unencripted) key to be used.  It has a short lifetime so the caller of this routine must use it
 * 		soon!
 *		Is of the form '2023-07-30 11:49:46'
 *
 */
function US_GenerateValidKey() {
	$now = new DateTime( "now", new DateTimeZone( "America/Los_Angeles" ) );
	$key = $now->format( DATE_TIME_FORMAT );
	return $key;
} // end of US_GenerateValidKey()



/*
 * US_GenerateBuriedKey - Generate a (possibly encrypted) string containing the passed key.
 *
 * PASSED:
 * 	$key - the key to be buried into the returned string
 * 	$encrypt - true if the returned string is encrypted, false if the returned string is kept
 * 		in the clear.
 *
 * RETURNED:
 * 	$buriedKey - the returned string containing the passed key.
 *
 * NOTES:
 * 	See the Notes for US_ExtractKeyFromValue() for a description of the $buriedKey.
 *
 */
function US_GenerateBuriedKey( $key, $encrypt ) {
	// generate the left-hand random part of our buried key:
	$str = rand();
	$head = sha1( $str );
	$head = substr( $head, 0, 11 );
	$head = "U" . $head;

	// generate the right-hand random part of our buried key:
	$str = rand();
	$tail = sha1( $str );
	$tail = substr( $tail, 0, 8 );
	
	// generate our cleartext result:
	$buriedKey = $head . $key . $tail;
	
	// encrypt it if required:
	if( $encrypt ) {
		$encryptedBuriedKey = openssl_encrypt( $buriedKey, ENCRYPT_METHOD, ENCRYPT_KEY );
		$buriedKey = "E" . $encryptedBuriedKey;
	}
	return $buriedKey;
} // end of US_GenerateBuriedKey()



/*
 * US_ExtractKeyFromValue - Extract the (unencripted) key from the passed (encrypted or
 *	unencrypted) value.
 *
 * PASSED:
 * 	$value - a string which contains the key.
 *
 * RETURNED:
 * 	$key - the extracted key, or an empty string if no key is found.
 *
 * NOTES:
 * 	$value is assumed to be of the form:
 * 		xxx...xxxKKK...KKKzzz...zzz
 * 	where
 * 		xxx...xxx is a string of exactly 12 unencripted characters, beginning with "U", 
 *			or more than 12 encrypted characters beginning with an "E", and
 * 		zzz...zzz is a string of exactly 8 unencripted characters (after being decrypted, if 
 *			necessary), and
 *		KKK...KKK is the unencrypted extracted key (after being decrypted, if necessary)
 * 	If $value does NOT begin with a "U" it must begin with a "E", in which case the remaining
 * 	part of $value is assumed to be an encrypted string, which will be decripted and must then
 * 	match the description above.  Any failure will result in an empty string being returned.
 * 	
 */
function US_ExtractKeyFromValue( $value ) {
	$key = "";
	$clear = "";
	// is $value encrypted?
	$firstChar = substr( $value, 0, 1 );
	if( !$firstChar ) {
		// no first char!
		$key = "";
	} else if( $firstChar == "E" ) {
		// encrypted string - decrypt it
		$realValue = substr( $value, 1 );
		$clear = openssl_decrypt( $realValue, ENCRYPT_METHOD, ENCRYPT_KEY );
	} else if( $firstChar == "U" ) {
		// $value is in the clear
		$clear = $value;
	} else {
		// invalid first char
		$key = "";
	}
	if( $clear != "" ) {
		// at this point $clear contains our cleartext key surrounded by junk
		$clear = substr( $clear, 12 );
		if( $clear ) {
			$clear = substr( $clear, 0, -8 );
		}
		if( $clear ) {
			$key = $clear;
		} else {
			$key = "";
		}
	}
	return $key;
} // end of US_ExtractKeyFromValue()


/*
 * US_TestValidKey - Extract a valid key from the passed encrypted key and, if successful,
 *		check to see if the valid key is still valid.
 *
 * PASSED:
 *	$encrypted - an encrypted key
 *
 * RETURNED:
 *	$result - one of: 0 if the valid key is valid, 1 if the encrypted key doesn't contain
 *		a valid key, 2 if the valid key lifetime has expired.
 *
 */
function US_TestValidKey( $encrypted ) {
	$result = 0;		// hope for the best...
	$key = '';
	$interval = 0;
	$timeZone = new DateTimeZone( "America/Los_Angeles" );	// doesn't matter, as long as we're consistent
	
	if( !isset( $encrypted ) || ($encrypted == '') ) {
		$result = 1;
	} else {
		$key = US_ExtractKeyFromValue( $encrypted );
		if( $key == '' ) {
			$result = 1;
		}
	}
	if( $result == 0 ) {
		// we have a key - is it valid?
		$dateTimeObject = new DateTime( $key, $timeZone );		// our "key" as a DateTime
		$now = new DateTime( "now", $timeZone );				// the current time as another key 

		if( DEBUG > 99 ) {
			$keyStr = $dateTimeObject->format( DATE_TIME_FORMAT );
			$nowStr = $now->format( DATE_TIME_FORMAT );
			error_log( "key str='$keyStr', nowStr='$nowStr'");
		}

		$interval = $now->diff( $dateTimeObject );	// the date/time difference between the two keys
		$bigDiff = $interval->y + $interval->m + $interval->d + $interval->h;
		$minDiff = $interval->i;
		if( ($bigDiff > 0) || ($minDiff > MAX_AGE_KEY) ) {
			// e.g. this key is over 50 minutes (ie MAX_AGE_KEY minutes) old...
			$result = 2;
		} else {
			// looks like a valid key!
		}
	}
	
	if( DEBUG > 10 ) {
		$intString = $interval->format( "%y years, %m months, %d days, %h hours, %i minutes, " .
			"%s seconds");
		error_log( "Prior to exit US_TestValidKey(): Max age of key: " . MAX_AGE_KEY . 
			" minutes,\n    current life of key: $intString" );
		if( $result == 0 ) {
			error_log( "Key is VALID" );
		} else if( $result == 1 ) {
			error_log( "Key NOT FOUND (INVALID)" );
		} else {
			error_log( "Key NOT VALID - EXPIRED" );
		}
		error_log( "exit US_TestValidKey(): result=$result." );
	}
	return $result;
} // end of US_TestValidKey()



// IS THE FOLLOWING USED??????

// 	if( US_KeysMatch( $passedKey, $expectedKey ) )
/*
 * US_KeysMatch - compare the two passed keys and return the result
 *
 * PASSED:
 * 	$passedKey - key to match (in the form generated by US_GenerateValidKey)
 * 	$expectedKey - other key to match (in the form generated by US_GenerateValidKey)
 *
 * RETURNED:
 * 	$result - true if the keys "match", false otherwise.
 *
 * NOTES:
 * 	The notion of "match" may allow the keys to be "close".  For example, this implementation
 * 	will use date/time as the key, and in that the case the keys will "match" if they are
 * 	fairly close to each other in time.
 *
 */
function US_KeysMatch( $passedKey, $expectedKey ) {
	$result = false;
	$passedDateTime = DateTime::createFromFormat( DATE_TIME_FORMAT, $passedKey );
	$expectedDateTime = DateTime::createFromFormat( DATE_TIME_FORMAT, $expectedKey );

	if( !$passedDateTime || !$expectedDateTime ) {
		// one/both passed "times" are not date/times!
		$result = false;
	} else {
		// how close are these two times?
		$interval = $passedDateTime->diff( $expectedDateTime, true );
		if( ($interval->y > 0) ||
			($interval->m > 0) ||
			($interval->d > 0) ||
			($interval->h > 0) ||
			($interval->i > 0) ||
			($interval->s > 55) ) {
			// not close enough!
			$result = false;
		} else {
			$result = true;
		}
	}
	return $result;	
} // end of US_KeysMatch()







// 		US_GetValidNames( $validNames, $uploadType );
function US_GetValidNames( &$validNames, &$uploadType ) {
	global $secretProps;
	if( DEBUG ) {
		//error_log( "US_GetValidNames() entered.");
	}
	$props = fopen( $secretProps, "r" ) or die ("Unable to open " . $secretProps . " - ABORT!" );
	while( ($line = fgets( $props )) !== false ) {
	if( DEBUG ) {
		//error_log( "US_GetValidNames() line='$line'.");
	}
		// remove comments
		$line = preg_replace( "/#.*$/", "", $line );
		// ignore blank or empty lines
		if( preg_match( "/^\s*$/", $line ) ) continue;
		$matches = array();
		if( preg_match( "/Name_$uploadType:/", $line ) ) {
			# found a valid name
			$line = preg_replace( "/^.*Name_[^:]+:\s*/", "", $line );
			preg_match( "/^(.*)>/", $line, $matches );
			$fullName = $matches[1];
			$fullName = preg_replace( "/\s*$/", "", $fullName );
			$line = preg_replace( "/^.*>\s*/", "", $line );
			preg_match( "/^(.*)\s*$/", $line, $matches );
			$validName = $matches[1];
			$validNames[$fullName] = $validName;
		}
	}
	//error_log( "US_GetValidNames(): valid names: " . var_export( $validNames, true ) );
	// above commented out to keep valid names out of the logs
} // end of US_GetValidNames()





/*
 * US_CodeToMessage - convert the error code generated when the upload failed into a text string.
 *
 * PASSED:
 * 	$code - the error code.
 *
 * RETURNED:
 * 	$message - a meaningful message representing the passed code.
 *
 */
function US_CodeToMessage($code) {
	switch ($code) {
		case UPLOAD_ERR_INI_SIZE:
			$message = "The uploaded file exceeds the upload_max_filesize directive in php.ini";
			break;
		case UPLOAD_ERR_FORM_SIZE:
			$message = "The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form";
			break;
		case UPLOAD_ERR_PARTIAL:
			$message = "The uploaded file was only partially uploaded";
			break;
		case UPLOAD_ERR_NO_FILE:
			$message = "No file was uploaded";
			break;
		case UPLOAD_ERR_NO_TMP_DIR:
			$message = "Missing a temporary folder";
			break;
		case UPLOAD_ERR_CANT_WRITE:
			$message = "Failed to write file to disk";
			break;
		case UPLOAD_ERR_EXTENSION:
			$message = "File upload stopped by extension";
			break;
		default:
			$message = "Unknown upload error: $code";
			break;
	}
	return $message;
} // end of US_CodeToMessage()


/*
 * US_SetError - Generate the error return if the FILE sent to our script failed to be uploaded.
 *
 * PASSED:
 * 	$err - one of:
 * 		- an error string to accompany the error.  This will be displayed to the user.
 * 		- an array of error strings, all of which will be sent to the browser, but only some of
 * 			them will be displayed to the user.  
 *
 * NOTES:
 * 	All control characters will be removed (e.g. newlines, etc.)
 * 	
 */
function US_SetError( $err ) {
	if( DEBUG > 10 ) {
		error_log( __FILE__ . ": US_SetError(): entered." );
	}

	$fullMsg = "";
	if( is_array( $err ) ) {
		foreach( $err as $line ) {
			$fullMsg .= $line . " ";
		}
	} else {
		$fullMsg = $err;
	}
	$len = strlen( $fullMsg );
	$fullMsg = preg_replace('/[[:cntrl:]]/', '', $fullMsg);
	$numCtrlChars = $len - strlen( $fullMsg );
	$len = strlen( $fullMsg );
	// escape double quotes:
	$fullMsg = preg_replace( '/"/', '\"', $fullMsg );
	$numQuotes = strlen( $fullMsg ) - $len;
	if( DEBUG ) {
		error_log( __FILE__ . ": US_SetError(): $numCtrlChars ctrl chars removed, " .
				  "$numQuotes quotes escaped: $fullMsg\n>>>Done Full<<<" );
	}
	echo '{"status":"error", "msg":"' . $fullMsg . '"}';
	if( DEBUG > 10 ) {
		error_log( __FILE__ . ": US_SetError(): return." );
	}
} // end of US_SetError()


//	US_InvalidRequest( $value, $expectedKey, $passedKey, $uploadType );
/*
 * US_InvalidRequest - generate the HTML response to an invalid attempt to access our
 * 		RSIND/OW Upload page.
 *
 * PASSED:
 * 	$value - the value (string) POSTed to this script (supposedly) from our html page.
 * 		Likely encrypted by US_ValidateUserName.  It is supposed to contain the key. 
 *		The clear text version of this value is passed as "$passedKey" below. 
 *		May be an empty string.
 * 	$expectedKey - the (unencrypted) key we expected to find inside the $value string, or
 *		an empty string if we don't know what we expected.
 * 	$passedKey - the actual key we used to generate the $value string.  May be an empty string
 *		if we don't have the key (usually a "UserName" supplied to Upload.html.)
 *	$uploadType - the type of upload attempted.
 *	$source - the source of this request (likely the file name of the script that discovered
 *		that the request was invalid.)
 *	$forEmail - (optional) an associative array to be sent with email. If 0 (the default) it
 *		will be ignored. If 1 then this routine will generate it's own associative array containing
 *		client headers. Otherwise it's assumed to be an associative array which will be displayed.
 *	$invalidUploadType - (optional) if 0 or missing then this was not an error caused by the
 *		user asking for an invalid upload type (e.g. asking to upload an OW result file when they
 *		only had permission to upload a RSIND file).
 *
 * NOTES:
 * 	We're actually generating a 404 page so the person who caused this invalid request to be
 * 	made doesn't get a hint as to what they almost did.  The passed values are never shown
 * 	to the user - they just get logged.
 */
function US_InvalidRequest( $value, $expectedKey, $passedKey, $uploadType, $source, $forEmail = 0, 
	$invalidUploadType = 0 ) {
	global $logHandle;
	global $UsersFullName;
	if( ! isset( $UsersFullName ) ) {
		$UsersFullName = "(unknown full name)";
	}
	$encrypted = US_GenerateBuriedKey( "$value.$expectedKey.$passedKey.", false );
	// it's possible $uploadType isn't defined (if someone hits one of the helper php files 
	// without logging in) so we'll pretend a value for the $uploadType to avoid any use
	// of an undefined value.
	if( ! isset( $uploadType ) ) {
		$uploadType = "Bad";
	}
	if( $uploadType == "OW" ) {
		$emailRecipients = OW_EMAIL_RECIPIENTS;
	} else {
		$emailRecipients = RSIND_EMAIL_RECIPIENTS;
	}
	US_GeneratePageHead( $uploadType );

	?>
	</head>
	<body>
	<h1 align="center">404:  Page Not Found</h1>
	<!-- Last updated 12/8/2019 , 0:-1 -->
	<!-- <p hidden> (Error code <?php echo $encrypted; ?> ) -->
	<p> (Error code posted: <?php echo $encrypted; ?> )
	<?php
		if( $invalidUploadType ) {
		?>
		<p>(Invalid upload type: <?php echo $uploadType; ?>)
		<?php
		}
	?>
	</body>
	</html>

	<?php

	if( $invalidUploadType ) {
		$msg =  "Invalid upload type ($uploadType) by $UsersFullName\n";
	} else {
		$msg =  "Invalid attempt to authenticate an Upload - $UsersFullName\n" .
			"Error code: '$encrypted'\n";
	}
	$msg .= "Invalid attempt discovered by: $source\n";
		
	if( $forEmail != 0 ) {
		if( $forEmail == 1 ) {
			$forEmail = US_GetHeaderList();
			$msg .= "Client Headers:\n";
		} else {
			$msg .= "Additional info:\n";
		}
    	foreach ($forEmail as $hdrName => $hdrValue) {
    		$msg .= "$hdrName: '$hdrValue'\n";
    	}
	}
	$msg .= "(Last updated 12/8/2019 , 0:-1)";
	US_SendEmail( $emailRecipients, "PAC Masters", "Invalid Request POSTed", $msg );
	if( DEBUG ) {
		error_log( __FILE__ . ": US_InvalidRequest(): value='$value', expectedKey='" .
				  "$expectedKey', passedKey='$passedKey', msg='$msg'" );
	}
	fwrite( $logHandle, __FILE__ . ": US_InvalidRequest(): value='$value', expectedKey='" .
				  "$expectedKey', passedKey='$passedKey', msg='$msg'" );
				  
} // end of US_InvalidRequest()



/*
 * US_ExpiredKey - generate the HTML response to an attempt to access one of our Upload
 * 		pages with an expired key.
 *
 * PASSED:
 *	$uploadType - the type of upload attempted.
 *	$source - the file name of the script that discovered the expired key.
 *
 * NOTES:
 */
function US_ExpiredKey( $uploadType, $source ) {
	global $logHandle;
	global $UsersFullName;
	
	$msg = [];
	$msg[] = "Expired Key";
	$msg[] = "<p>I'm sorry - your session has expired. Please log in again ";
	$msg[] = "<a href='https://pacmdev.org/points/Upload/Upload.html'>here</a>.";
//US_SetError( "Expired Key");
US_SetError( $msg );
	
	
	if( $uploadType == "OW" ) {
		$emailRecipients = OW_EMAIL_RECIPIENTS;
	} else {
		$emailRecipients = RSIND_EMAIL_RECIPIENTS;
	}
if(0) {
	US_GeneratePageHead( $uploadType );
	?>
	</head>
	<body>
	<h1 align="center">Session Expired</h1>
	<p>I'm sorry - your session has expired. Please log in again 
		<a href="https://pacmdev.org/points/Upload/Upload.html">here</a>.
	</body>
	</html>

	<?php
}
	$msg = "Session expired for $UsersFullName (found in $source)";
	US_SendEmail( $emailRecipients, "PAC Masters", "Invalid Request POSTed - Expired Key", $msg );
	if( DEBUG ) {
		error_log( __FILE__ . ": US_ExpiredKey(): msg='$msg'" );
	}
	fwrite( $logHandle, __FILE__ . ": US_ExpiredKey(): msg='$msg'" );
				  
} // end of US_ExpiredKey()





// return a file pointer or false.
/*
 * US_CreateDirIfNecessary - create the passed directory if it doesn't already exist.
 *
 * PASSED:
 * 	$dir - the name of the directory.  Can be a simple name or partial path (relative to CWD), or a full
 * 		path name.
 *
 * RETURNED:
 * 	$status - an empty string if all is OK.  Error message if there is a failure.
 *
 */
function US_CreateDirIfNecessary( $dir ) {
	$status = "";
	// create the destination directory if it doesn't exist:
	$okDir = 1;
	if( !file_exists( $dir ) ) {
		$okDir = mkdir( $dir, 0700, true );
		if( !$okDir ) {
			$status = "Unable to create destination directory '$dir' - uploaded file not saved!";
		}
	}
	return $status;
} // end of US_CreateDirIfNecessary()



// 		$message = US_FileAlreadyExists( $destinationDir, $convertedFileName );
/*
 * US_FileAlreadyExists - see if the passed file already exists
 *
 * PASSED:
 * 	$destinationDir - the directory holding the file
 * 	$fileName - the file we look for
 *
 * RETURNED:
 * 	$status - an empty string if the file does not exist in the directory, otherwise a message
 * 		saying that the file already exists.
 *
 */
function US_FileAlreadyExists( $destinationDir, $fileName ) {
	$status = "";
	$fullFileName = "$destinationDir/$fileName";	// may be partial path relative to CWD
	if( file_exists( $fullFileName ) ) {
		$status = "File already exists - upload Aborted!";
	}
	return $status;
} // end of US_FileAlreadyExists()







/*
 * US_GeneratePageHead - write out the HTML to start our page
 *
 */
function US_GeneratePageHead( $uploadType ) {
	if( DEBUG ) {
		error_log( "inside US_GeneratePageHead with uploadType='$uploadType'" );
	}
	?>
	<!DOCTYPE html>
	<html lang="en" class="no-js">
	<head>
		<meta charset="utf-8">
		<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
		<script src="jqUpload/assets/js/jquery.ui.widget.js"></script>
		<script src="jqUpload/assets/js/jquery.iframe-transport.js"></script>
		<script src="jqUpload/assets/js/jquery.fileupload.js"></script>

	<?php
	if( DEBUG ) {
		echo "<title>Upload a New $uploadType File Debugging</title>\n";
	} else {
		echo "<title>Upload a New $uploadType File</title>\n";
	}
} // end of US_GeneratePageHead()



// IS THE FOLLOWING USED??????

/*
 * US_GeneratePageMiddle - write out the HTML to begin the content of our page
 *
 */
function US_GeneratePageMiddle() {
	?>
	</head>
	<body>
	<?php
} // end of US_GeneratePageMiddle()



// IS THE FOLLOWING USED??????
// yes - owstart.php

/*
 * US_GeneratePageEnd - write out the HTML to end our page
 *
 */
function US_GeneratePageEnd() {
	?>
	</body>
	</html>
	<?php
} // end of US_GeneratePageEnd()



/*
 * US_SendEmail -
 *
 */
function US_SendEmail( $to, $from, $subject, $email ) {
	$headers = "From: $from Upload <uploads@pacificmasters.org>" . "\r\n" .
		"Reply-To: $from Upload <uploads@pacificmasters.org>" . "\r\n" .
		'X-Mailer: PHP/' . phpversion();
	// if this email isn't going to one of the general "upload" mailboxes then we must be debugging...
	if( strpos( $to, "upload" ) === false ) {
		$subject .= " (debug mode)";
	}
	if( DEBUG > 1 ) {
		error_log( "US_SendEmail(): to:'$to', subject:'$subject', email:'$email', headers:'$headers'\n" );
		if( DEBUG_RSIND ) {
			error_log( "Debugging RSIND - email only sent to '" . RSIND_EMAIL_RECIPIENTS . "'\n" );
		} else {
			error_log( "Live RSIND - email sent to '" . RSIND_EMAIL_RECIPIENTS . "'\n" );
		}
	}

	if( 1 ) {
		if( !mail( $to, $subject, $email, $headers  ) ) {
			error_log( "Mail to $to not successful\n" );
		} else {
			if( DEBUG > 1 ) {
				error_log( "email ok");
			}
		}
	} else {
		error_log( "US_SendEmail() DISABLED: to:'$to', subject:'$subject', email:'$email', headers:'$headers'\n" );
	}
} // end of US_SendEmail()



//		$pretag = US_ComputeSavedFilePretag( $data['unique'], $data['cat'], 
//			preg_replace( "/\s/", "", $data['name'] ) );
/*
** US_ComputeSavedFilePretag - Generate the first part of a saved uploaded file name.
**
** PASSED:
**	$unique - intended to be the unique id of the event represented by the file to be saved.
**	$cat - the categoryof the event
**	$eventName - the name of the event
**
** RETURNED:
**	$pretag - a string combining the passed parameters that uniquely represents a 
**		saved uploaded file. It's used to name the uploaded file.
**
** NOTE: 27OCT2024: Since this $pretag is used as part of a filename and this filename
**	is used in a rename() command we MUST NOT have any '/'s in the simple file name as
**	this confuses rename() which then thinks it's a directory path. No obvious way to get
**	around this (the -T option of command line 'mv' doesn't work!). So, we'll convert all '/'s
**	in the $eventName into underscores (_).
*/
function US_ComputeSavedFilePretag( $unique, $cat, $eventName ) {
		$eventName = str_replace( "/", "_", $eventName );
		$pretag = $unique . "-" . $cat . "-" . $eventName . "=";
		return $pretag;

} // end of US_ComputeSavedFilePretag


// 		list( $existingFileName, $existingFileDate) = 
//			US_FileExistsWithThisPretag( $pretag, $destinationDirArchive );
function US_FileExistsWithThisPretag( $pretag, $destinationDirArchive ) {
	if( DEBUG > 99 ) {
		error_log( "owStart.php::US_FileExistsWithThisPretag(): entered with pretag='$pretag', " .
			"destinationDirArchive='$destinationDirArchive'" );
	}
	
	// first, make sure the $destinationDirArchive exists:
	if( !is_dir( $destinationDirArchive ) ) {
		// either the $destinationDirArchive doesn't exist, or it does esist but is 
		// not a directory. 
		if( is_file( $destinationDirArchive ) ) {
			// oops - it's a regular file!
			error_log( "US_FileExistsWithThisPretag(): '$destinationDirArchive' exists but is a regular file! Abort!\n" );
			exit;
		} else {
			// neither file nor directory exists - create directory
			$status = mkdir( $destinationDirArchive, 0750 );
		}
	}
	
	
	$existingFileName = "";
	$existingFileDate = "";
	
	$pattern = "/^" . $pretag . "(.*$)/";

	foreach( new DirectoryIterator( $destinationDirArchive ) as $fileInfo ) {
		$fileName = $fileInfo->getFilename();
		$filePretagExists = preg_match( $pattern, $fileName, $matches );
		if( $filePretagExists ) {
			// we found a file with the passed pretag
			$existingFileName = $matches[1];
			$existingFileDate = date( "D, M j, Y e", $fileInfo->getMTime() );
			break;
		} else {		
		}
	}
	
	if( DEBUG > 99 ) {
		error_log( "owStart.php::US_FileExistsWithThisPretag(): existingFileName='$existingFileName', " .
			"existingFileDate='$existingFileDate'" );
	}
	return array( $existingFileName, $existingFileDate );

} // end of US_FileExistsWithThisPretag()



/*
 * US_GenerateDropZone -
 *  currently only used by rsind - should be moved into rsind.php
 */
function US_GenerateDropZone( $UsersFullName, $uploadType ) {
	if( DEBUG ) {
		error_log( "inside US_GenerateDropZone" );
	}
	if( $uploadType == "OW" ) {
		$emailRecipients = OW_EMAIL_RECIPIENTS;
	} else {
		$emailRecipients = RSIND_EMAIL_RECIPIENTS;
	}

	?>
	<style>
		#drop_zone {
			position: fixed;
			overflow: auto;
			padding-right:5px;
			margin:0;
			box-sizing: border-box;
			top:0;
			left:0;
			width: 100%;
			height: 100%;
			border: 5px solid blue;
			text-align: center;
		}
		#status_area {
			display: inline-block;
			vertical-align: top;
			margin-right: auto;
			margin-left: auto;
			text-align:left;
			font-size: 12px;
			color: black;
			overflow-wrap: break-word;
			word-wrap: break-word;
			hyphens: auto;
			bottom: 20px;
			overflow:auto;
		}
		#status-text {
			margin: 0 auto;
		}
		.dropDiv {
			margin-right: 100px;
			margin-left: 50px;
		}
	</style>
	
	<script>
		var debug = <?php echo DEBUG; ?>;
		var myURL = location.href;
		if( debug ) console.log( "my url is '" + myURL + "'" );
		function dragOverHandler(ev) {
			if( debug ) console.log('File(s) in drop zone');
			// Prevent default behavior (Prevent file from being opened)
			ev.preventDefault();
			document.getElementById( "drop_zone" ).style.borderColor = "red";
		} // end of dragOverHandler()
		function dragOverLeaveHandler( ev ) {
			// Prevent default behavior (Prevent file from being opened)
			ev.preventDefault();
			document.getElementById( "drop_zone" ).style.borderColor = "blue";
		} // end of dragOverLeaveHandler()

		/*
		 * DropMsg - this function is executed when a user message is clicked on.  When this happens
		 * 	the corresponding div (passed id) is shown (if hidden) or hidden (if shown).
		 */
		function DropMsg( id ) {
			$('#'+id).toggle();
		}
		///////////////////////////////////////////////////
		// Once our page is loaded then execute the following:
		///////////////////////////////////////////////////
		$(function() {
			$('#uploadDragDrop').attr( 'action', myURL );
		
			$('#uploadDragDrop').fileupload({
				dropZone: $('#drop_zone'),
				formData: function( form ) {
					return form.serializeArray();
				},
				add: function (e, data) {
					if( debug ) {
						console.log( "upload add: ");
						console.log( e );
						console.log( data);
					}
					// Automatically upload the file once it is added to the queue
					var jqXHR = data.submit();
				},
				done:function(e, data){
					if( debug ) {
						console.log( "upload done: ");
						console.log( e );
						console.log( data);
					}
					var fileName = data.files[0].name;
					var result = data.result;
					// result looks something like this:   {"status":"error", "msg":"$err"}
					if( debug ) console.log( "fileName: '" + fileName + "', result: '" + result + "'" );
					var obj = "JSON Failed";
					var startMsg = "";
					var fullMsg = "";
					var hidden = "(no hidden messages)";
					var drop = "(no drop messages)";
					var nextId = GetNextId();
					var nextIdStr = "id" + nextId;
					try {
						var obj = JSON.parse( result );
					} catch( err ) {
						if( err.name == "SyntaxError" ) {
							// if necessary we may have to do something in here if we can't figure out the syntax error
						}
						startMsg = "Upload of " + fileName + " FAILED!  JSON Syntax Error.";
						fullMsg = "\n<p onclick=\"DropMsg('" + nextIdStr + "\')\" style='color:red'>" +
							startMsg + "&nbsp;&nbsp;&nbsp;</p>";
						fullMsg += FormatDropMessages( nextIdStr, err.message );
						startMsg += "  " + err.message;
					}
					if( obj != "JSON Failed" ) {
						var status = obj.status;
						var msg2 = ExtractMsg( obj.msg );
						hidden = ExtractHiddenMsg( obj.msg );
						drop = ExtractDropMsg( obj.msg );
						if( status == "error" ) {
							startMsg = "Upload of " + fileName + " FAILED!  " + msg2;
							fullMsg = "\n<p onclick=\"DropMsg('" + nextIdStr + "\')\" style='color:red'>" +
								startMsg;
							fullMsg += "</p>\n";
						} else {
							startMsg = "Upload of " + fileName + " SUCCESSFUL!  " + msg2;
							fullMsg = "<p onclick=\"DropMsg('" + nextIdStr + "\')\" style='color:black'>" +
								startMsg;
							fullMsg += "</p>\n";
						}
						fullMsg += FormatDropMessages( nextIdStr, drop );
						fullMsg += "\n<!-- " + hidden + "-->\n";
					}
					startMsg += "\n";
					UpdateScreenWithStatus( fullMsg, e, startMsg, drop, hidden );
				},
				fail:function(e, data){
					// Something has gone wrong!
					var fileName = data.files[0].name;
					var startMsg = "";
					var fullMsg = "";
					if( debug ) {
						console.log( "upload error: " );
						console.log( "e: ");
						console.debug( e );
						console.log( "data: ");
						console.debug( data );
					}
					startMsg = "Upload of " + fileName + " FAILED!  (Internal Error!)";
					fullMsg = "<p style='color:red'>" + startMsg + "</p>";
					UpdateScreenWithStatus( fullMsg, e, startMsg, 
						"(The $('#uploadDragDrop').fileupload() failed.)", "" );
				}
			});
		});
		


		// 						var nextId = GetNextId();
		function GetNextId() {
			var id=$("#count").text();
			var newId = Number(id) + 1;
			$("#count").text(newId);
			if( debug ) console.log( "GetNextId: return " + id + ", next id is " + newId );
			return id;
		}
		
		//						fullMsg += FormatDropMessages( nextIdStr, drop );
		function FormatDropMessages( idStr, drop ) {
			return "<div class='dropDiv' id='" + idStr + "' style=\"display:none\">" + drop + "</div>";
		}
		
		/*
		 * ExtractMsg - extract the user message from a JSON message possibly containing a hidden message
		 *
		 * PASSED:
		 * 	msg - a string of the form
		 * 			xxxx  yyyy zzzz....
		 * 		where
		 * 			xxxx is the user message.
		 * 			yyyy is an optional drop message
		 * 			zzzz is 0 or more hidden messages
		 * 		and
		 * 			yyyy is of the form
		 * 				[[[ drop message... ]]]
		 * 			where
		 * 				drop message is one or more strings of the form
		 * 					! WARNING....
		 * 				or
		 * 					! ERROR....
		 * 		and
		 * 			zzzz.... is of the form
		 * 				((( hidden message ))) ....
		 * 			where
		 * 				hidden message is a string not containing ((( nor ))).
		 *
		 * 		NOTE:
		 * 			There can be 0 or more hidden messages of the form '(((yyyy)))'.
		 * 		and
		 * 			Exactly one 'xxxx' must be present but all the rest are optional
		 *
		 * RETURNED:
		 * 	msg - the user message, which is the 'xxxx' above.
		 *
		 */
		function ExtractMsg( msg ) {
			msg2 = msg.replace( /\[\[\[.*$/, "" );
			if( msg2.length == msg.length ) {
				// no drop messages so we have to remove hidden messages until end of string
				msg2 = msg.replace( /\(\(\(.*$/, "" );
			}
			return msg2;
		} // end of ExtractMsg()
		
		
		
		/*
		 * ExtractHiddenMsg - extract the hidden message(s) from a JSON message
		 *
		 * PASSED:
		 * 	msg - a string of the form describe by ExtractMsg()
		 *
		 * RETURNED:
		 * 	msg - the hidden message, e.g. the set of zzzz substrings concatenated (see ExtractMsg).
		 *
		 */
		function ExtractHiddenMsg( msg ) {
			var hidden = msg.indexOf( "(((" );
			if( hidden > 0 ) {
				// extract the hidden part of the message
				msg = msg.substr( hidden );
				msg = msg.replace( /\(\(\(/g, "" );
				msg = msg.replace( /\)\)\)/g, "" );
			} else {
				msg = "";
			}
			return msg;
		} // end of ExtractHiddenMsg()
								
		
		/*
		 * ExtractDropMsg - extract the drop message from a JSON message
		 *
		 * PASSED:
		 * 	msg - a string of the form describe by ExtractMsg()
		 *
		 * RETURNED:
		 * 	msg - the drop message, e.g. the yyyy substring bounded by [[[ and ]]]
		 *
		 * NOTES:
		 * 	Since the primary reason for the drop messages is to convey errors or warnings,
		 * 	the returned msg will be modified to insert a <br> in front of every ! WARNING
		 * 	and ! ERROR.
		 *
		 */
		function ExtractDropMsg( msg ) {
			// if there are any hidden messages in the passed msg then remove them:
			msg = msg.replace( /\(\(\(.*$/, "" );
			// now extract the drop message (if any)
			var drop = msg.indexOf( "[[[" );
			if( drop > 0 ) {
				// extract the drop part of the message
				msg = msg.substr( drop );
				msg = msg.replace( /\[\[\[/g, "" );
				msg = msg.replace( /\]\]\]/g, "" );
				// add some <br>'s
				msg = msg.replace( /! ERROR/g, "<br>! ERROR" );
				msg = msg.replace( /! WARNING/g, "<br>! WARNING" );
			} else {
				msg = "";
			}
		
			return msg;
		} // end of ExtractDropMsg()
						
								
		/*
		 * 	UpdateScreenWithStatus();
		 *
		 */
		function UpdateScreenWithStatus( fullMsg, e, startMsg, drop, hidden ) {
			document.getElementById( "NoUploads" ).style.display="none";
			document.getElementById( "initialPrompt" ).style.display="none";
			document.getElementById( "followingPrompt" ).style.display="block";
			document.getElementById( "status-text" ).innerHTML = fullMsg + "<p><hr>" +
				document.getElementById( "status-text" ).innerHTML;
			dragOverLeaveHandler( e );
			
			// send email
			// if drop contains "WARNING" or "ERROR" we're going to include that in the subject
			// of the email:
			errMsg = "";		// assume no error or warning
			if( startMsg.includes( "ERROR" ) ) {
				errMsg = " - ERROR!";
			} else if( startMsg.includes( "WARNING" ) ) {
				errMsg = " - WARNING!";
			} else if( startMsg.includes( "FAILED" ) ) {
				errMsg = " - FAILED!";
			}
			drop = drop.replace( /<br>/g, "\n" );
			msg = startMsg + "\n" + drop + "\n\n" + hidden;
			
			if( debug ) {
				console.log( "errMsg='" + errMsg + "', drop='" + drop + "', fullMsg='" + fullMsg + "', " +
					"e='" + e + "', startMsg='" + startMsg + "', hidden='" + hidden + "'" );
			}

			if( fullMsg.indexOf( "Expired Key" ) == -1 ) {
				if( debug ) {
					console.log( "post email at end of UpdateScreenWithStatus()" );
					console.log( "fullMsg=<<<" + fullMsg + ">>>" );
					console.log( "indexOf='" + fullMsg.indexOf( "Expired Key" ) + ";" );
					
				}
				// send an email UNLESS it's an invalid key (because in that case we already sent
				// an email)
				$.post( myURL, {"to" : <?php echo "'" . $emailRecipients . "'"; ?>, 
					"subject" : "<?php echo $uploadType;?> file uploaded by <?php echo "'" . $UsersFullName . "'"; ?>" + errMsg,
					"emailAck" : msg}, function( data ) {
				});
			}
			
		} // end of UpdateScreenWithStatus();


	</script>
	</head>
	<body>
	<form id="uploadDragDrop" method="post" action="filled in by jquery(Rsind.php)" enctype="multipart/form-data"
		formData='{"script":"true"}'>
			<div id="drop_zone" ondragover="dragOverHandler(event);" ondragleave="dragOverLeaveHandler(event);">
			  <h1 align="center">Upload a New <?php echo $uploadType;?> File</h1>
			  <p id="initialPrompt" style='text-align:center; font-size:22px; color:blue'>
				Drag and drop a file onto this window to upload a new <?php echo $uploadType;?> file ...</p>
			  <p id="followingPrompt" style='text-align:center; font-size:22px; color:blue; display:none'>
				Drag and drop another file onto this window or close this window when done.</p>				
				<div id="status_area">
					<h3 align="center" style='text-decoration: underline;color:black'>Upload Status</h3>
					<div id="status-text">
						<p id='NoUploads'>(No uploads performed yet)</p>
					</div>
				</div>
			</div>
		</div>
	</form>
	<div id="count" style="display:none">1</div>
	</body>
	</html>
	<?php
	// Done drawing the drop zone for the user - let them decide what to do:
	if( DEBUG ) {
		error_log( "EXIT Rsind.php  when at end of US_GenerateDropZone" );
	}
	exit;


} // end of US_GenerateDropZone()



/*
 * US_GetHeaderList - get a list of headers sent along with a client request to us.
 *
 */
function US_GetHeaderList() {
    //create an array to put our header info into.
    $headerList = array();
    //loop through the $_SERVER superglobals array.
    foreach ($_SERVER as $name => $value) {
        //if the name starts with HTTP_, it's a request header.
        if (preg_match('/^HTTP_/',$name)) {
            //convert HTTP_HEADER_NAME to the typical "Header-Name" format.
            //$name = strtr(substr($name,5), '_', ' ');
            //$name = ucwords(strtolower($name));
            //$name = strtr($name, ' ', '-');
            //Add the header to our array.
            $headerList[$name] = $value;
        }
    }
    //Return the array.
    return $headerList;
} // end of US_GetHeaderList()


//		$pretag = US_SanatizeRegEx( $pretag );
/*
 * US_SanatizeRegEx - convert a string to be used as a regex to escape all special meta
 *		characters.
 *
 * NOTES:  For example, suppose you want to find the string
 *		This \\ dog looks ^ and sees $ always.
 *	Notice that this simple string contains regex meta characters which, if used in a 
 *	pattern matching operation, will be interpretated instead of just used as the characters
 *	they represent.  To match the above string as part of a regex you want the string
 *	to look like this:
 *		This \\\\ dog looks \^ and sees \$ always\.
 *	That's what this function would return.
 */
function US_SanatizeRegEx( $plainString ) {
	$meta = "\\.^*+?{}[]|()";
		# NOTE: meta characters are:
		# - \ (Backslash)
		# - . (Full stop)
		# - ^ (Carat)
		# - * (Asterix)
		# - + (Plus)
		# - ? (Question Mark)
		# - { (Opening curly brace)
		# - } (Closing curly brace) 
		# - [ (Opening brace)
		# - ] (Closing brace)
		# - | (Pipe)
		# - ( (Opening parens)
		# - ) (Closing parens)

	foreach( str_split( $meta ) as $mchar ) {
		$plainString = str_replace( $mchar, "\\" . $mchar, $plainString );
	}

	return $plainString;

} // end of US_SanatizeRegEx()





if( DEBUG > 10 ) {
	error_log( "Exit UploadSupport.php\n" );
}

?>

